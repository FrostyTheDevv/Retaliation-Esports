// Retaliation Esports Database Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id            String   @id @default(cuid())
  discordId     String?  @unique // Optional - for Discord OAuth (admin only)
  username      String   @unique // Required for all users
  email         String   @unique // Required for all users
  password      String? // Hashed password - null for Discord OAuth users
  discriminator String?
  avatar        String?
  guildRoles    String[] // Array of Discord role IDs (admin only)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  captainOfTeams      Team[]             @relation("TeamCaptain")
  teamMemberships     TeamMember[]
  auditLogs           AuditLog[]
  tournamentSignups   TournamentSignup[] @relation("UserSignups")
}

// ============================================
// ROSTER SYSTEM
// ============================================

model Roster {
  id             String   @id @default(cuid())
  name           String
  tag            String? // Team abbreviation
  primaryColor   String // Hex color
  secondaryColor String? // Hex color
  image          String? // Logo URL
  description    String?  @db.Text
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  players Player[]

  @@index([isActive])
}

model Player {
  id         String  @id @default(cuid())
  name       String
  inGameName String?
  role       String? // Position/role in team
  image      String? // Profile image URL
  bio        String? @db.Text

  // Stats (optional)
  goals   Int?
  assists Int?
  saves   Int?

  // Social links
  twitter   String?
  twitch    String?
  youtube   String?
  instagram String?
  discord   String?
  steam     String?

  rosterId String
  roster   Roster @relation(fields: [rosterId], references: [id], onDelete: Cascade)

  displayOrder Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([rosterId])
}

// ============================================
// TEAM SYSTEM
// ============================================

model Team {
  id             String   @id @default(cuid())
  name           String
  tag            String?
  logo           String?
  primaryColor   String?
  secondaryColor String?
  timezone       String?  // IANA timezone (e.g., "America/New_York")
  captainId      String?
  captain        User?    @relation("TeamCaptain", fields: [captainId], references: [id], onDelete: SetNull)
  isActive       Boolean  @default(true)
  verified       Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  members        TeamMember[]
  signups        TournamentSignup[]
  matchesAsTeam1 Match[]            @relation("Team1Matches")
  matchesAsTeam2 Match[]            @relation("Team2Matches")
  teamStatus     TeamStatus?

  @@index([isActive])
  @@index([verified])
}

model TeamMember {
  id     String  @id @default(cuid())
  teamId String
  team   Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  playerName String // In case user doesn't have account
  role       String   @default("player") // captain, player, substitute
  joinedAt   DateTime @default(now())

  @@unique([teamId, userId])
  @@index([teamId])
  @@index([userId])
}

// ============================================
// TOURNAMENT SYSTEM
// ============================================

model Tournament {
  id          String   @id @default(cuid())
  name        String
  description String   @db.Text
  bannerImage String?
  images      String[] // Gallery images

  // Dates
  startDate            DateTime
  registrationDeadline DateTime

  // Links
  discordLink   String?
  rulesLink     String?
  streamLink    String?
  externalLinks Json? // Array of {title, url}

  // Configuration
  requirements   String? @db.Text
  gameMode       String // "1v1", "2v2", "3v3"
  format         String // "single_elimination", "double_elimination"
  bestOf         Int     @default(1) // BO1, BO3, BO5, BO7
  customRounds   Json? // Custom best-of per round {roundNumber: bestOf}
  customRoundNames Json? // Custom round names {roundNumber: name}
  maxTeams       Int?
  minTeamSize    Int?
  maxTeamSize    Int?
  allowRandomize Boolean @default(false)
  manualSeeding  Boolean @default(false)
  thirdPlaceMatch Boolean @default(false)

  // Prize
  prizeInfo String? @db.Text

  // Status
  status String @default("draft") // draft, open, closed, ongoing, completed

  // Settings
  requireEmailVerification Boolean   @default(true)
  checkInEnabled           Boolean   @default(false)
  checkInStart             DateTime?
  checkInEnd               DateTime?
  customQuestions          Json? // Array of registration questions
  
  // Notification Settings
  emailReminders Boolean @default(true)
  reminderHours  Int     @default(24) // Hours before event to send reminder
  discordReminders Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  signups TournamentSignup[]
  bracket Bracket?
  matches Match[]

  @@index([status])
  @@index([startDate])
}

model TournamentSignup {
  id           String     @id @default(cuid())
  tournamentId String
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  // User who registered (required)
  userId String
  user   User   @relation("UserSignups", fields: [userId], references: [id], onDelete: Cascade)

  teamId String?
  team   Team?   @relation(fields: [teamId], references: [id], onDelete: SetNull)

  // Team info
  teamName       String
  captainEmail   String // Redundant with user.email but kept for reference
  captainDiscord String?

  // Players info
  playersInfo Json // Array of player details

  // Verification
  isVerified        Boolean   @default(false)
  verificationToken String?   @unique
  verifiedAt        DateTime?

  // Status
  status      String    @default("pending") // pending, approved, rejected, checked_in
  checkedInAt DateTime?

  // Notifications
  reminderSent Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tournamentId, userId]) // One signup per user per tournament
  @@unique([tournamentId, teamName])
  @@index([tournamentId])
  @@index([status])
  @@index([isVerified])
}

// ============================================
// BRACKET SYSTEM
// ============================================

model Bracket {
  id           String     @id @default(cuid())
  tournamentId String     @unique
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  format      String // "single_elimination", "double_elimination"
  bracketData Json // Full bracket structure
  isLocked    Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Match {
  id           String     @id @default(cuid())
  tournamentId String
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  // Match info
  round       Int
  matchNumber Int
  bracketType String? // "winners", "losers", "grand_finals"

  // Teams
  team1Id String?
  team1   Team?   @relation("Team1Matches", fields: [team1Id], references: [id], onDelete: SetNull)
  team2Id String?
  team2   Team?   @relation("Team2Matches", fields: [team2Id], references: [id], onDelete: SetNull)

  // Scores
  team1Score Int?
  team2Score Int?
  winnerId   String?

  // Team-submitted results
  team1SubmittedScore Int?
  team2SubmittedScore Int?
  team1SubmittedWinner String?
  team2SubmittedWinner String?
  resultsMatch Boolean @default(false)

  // Status
  status      String    @default("pending") // pending, ready, live, completed, disputed, postponed, paused
  scheduledAt DateTime?
  startedAt   DateTime?
  completedAt DateTime?
  pausedAt    DateTime?
  pauseReason String?   @db.Text

  // Check-in system
  team1CheckedIn  Boolean   @default(false)
  team2CheckedIn  Boolean   @default(false)
  team1CheckInTime DateTime?
  team2CheckInTime DateTime?
  checkInDeadline DateTime?
  team1NoShow    Boolean   @default(false)
  team2NoShow    Boolean   @default(false)

  // Lobby/Server info
  lobbyCode String?
  serverInfo String? @db.Text

  // Postponement
  postponementRequested Boolean @default(false)
  postponementReason    String? @db.Text
  postponementRequestedBy String?
  postponementApproved  Boolean @default(false)

  // Additional data
  vodUrl  String?
  notes   String? @db.Text
  previousWinnerId String?
  rollbackCount    Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  disputes Dispute[]
  technicalIssues TechnicalIssue[]
  matchHistory MatchHistory[]

  @@index([tournamentId])
  @@index([status])
  @@index([scheduledAt])
}

model Dispute {
  id      String @id @default(cuid())
  matchId String
  match   Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)

  // Dispute info
  reportedByTeamId String?
  category         String // score_incorrect, no_show, technical_issue, rule_violation, other
  description      String  @db.Text
  evidence         String[] // Array of evidence URLs (screenshots, videos)

  // Admin review
  status      String    @default("pending") // pending, under_review, resolved, dismissed
  reviewedBy  String? // Admin user ID
  resolution  String? @db.Text
  action      String? // overturn, uphold, rematch, disqualify, no_action
  reviewedAt  DateTime?
  reviewNotes String? @db.Text

  // Match state before dispute
  originalTeam1Score Int?
  originalTeam2Score Int?
  originalWinnerId   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([matchId])
  @@index([status])
}

model TechnicalIssue {
  id      String @id @default(cuid())
  matchId String
  match   Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)

  // Issue info
  reportedByTeamId String
  issueType        String // connection, server, game_crash, lag, audio, other
  description      String @db.Text
  severity         String @default("medium") // low, medium, high, critical
  
  // Admin response
  status         String    @default("open") // open, investigating, resolved, closed
  assignedTo     String? // Admin user ID
  resolution     String? @db.Text
  resolvedAt     DateTime?
  
  // Actions taken
  matchPaused    Boolean @default(false)
  requiresRematch Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([matchId])
  @@index([status])
  @@index([severity])
}

model MatchHistory {
  id       String @id @default(cuid())
  matchId  String
  match    Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)

  // History entry
  action      String // score_updated, winner_changed, status_changed, paused, resumed, rolled_back
  performedBy String // User ID (admin or team captain)
  performedByRole String // admin, team_captain
  
  // Previous state
  previousState Json?
  newState      Json?
  
  reason String? @db.Text
  
  createdAt DateTime @default(now())

  @@index([matchId])
  @@index([createdAt])
}

model TeamStatus {
  id     String @id @default(cuid())
  teamId String @unique
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  // Current status
  status String @default("offline") // offline, online, ready, in_match, away
  
  // Match context
  currentMatchId String?
  lastSeenAt     DateTime @default(now())
  
  // Penalties
  noShowCount    Int @default(0)
  warningCount   Int @default(0)
  isBanned       Boolean @default(false)
  banReason      String? @db.Text
  bannedUntil    DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([currentMatchId])
}

model Notification {
  id         String @id @default(cuid())
  
  // Target
  recipientType String // admin, team, user
  recipientId   String? // Team ID or User ID (null for all admins)
  
  // Content
  type     String // match_starting, check_in_required, result_submitted, dispute_filed, issue_reported, intervention_needed
  title    String
  message  String @db.Text
  priority String @default("normal") // low, normal, high, urgent
  
  // Context
  tournamentId String?
  matchId      String?
  relatedUrl   String?
  
  // Status
  read       Boolean   @default(false)
  readAt     DateTime?
  dismissed  Boolean   @default(false)
  
  createdAt DateTime @default(now())

  @@index([recipientId, read])
  @@index([type])
  @@index([priority])
  @@index([createdAt])
}

// ============================================
// SUPPORT SYSTEM
// ============================================

model SupportTicket {
  id         String  @id @default(cuid())
  name       String
  email      String
  discord    String?
  category   String // tournament_question, technical_issue, etc.
  priority   String  @default("normal") // normal, urgent
  subject    String
  message    String  @db.Text
  attachment String?

  status     String  @default("new") // new, in_progress, resolved
  assignedTo String?
  response   String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([category])
}

model FAQ {
  id           String  @id @default(cuid())
  category     String
  question     String  @db.Text
  answer       String  @db.Text
  displayOrder Int     @default(0)
  isPublished  Boolean @default(true)
  viewCount    Int     @default(0)
  helpfulCount Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([isPublished])
}

// ============================================
// AUDIT LOG
// ============================================

model AuditLog {
  id     String  @id @default(cuid())
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  action     String // create, update, delete
  resource   String // roster, tournament, bracket, etc.
  resourceId String?
  details    Json? // Additional data about the action
  ipAddress  String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([resource])
  @@index([createdAt])
}
